第六章 Connect
=============================
本章内容：
    搭建一个Connect程序
    Connect中间件的工作机制
    为什么中间件的顺序很重要
    挂载中间件和服务器
    创建可配置的中间件
    使用错误处理中间件

Connect是一个框架，它使用被称为中间件的模块化组件，
以可重用的方式实现Web程序中的逻辑。
在Connect 中，中间件组件是一个函数，
它拦截HTTP服务器提供的请求和响应对象，执行逻辑，
然后或者结束响应，或者把它传递给下一个中间件组件。
Connect 用分派器把中间件链接在一起。

在Connect 中，你可以使用自己编写的中间件，
但它也提供了几个常用的组件，
可以用来做请求日志、静态文件服务、请求体解析、会话管理。
对于想构建自己的高层Web 框架的开发人员来说，
Connect 就像一个抽象曾，因为Connect 很容易扩展，
在其上构建东西也很容易。

Express 构建在Connect 之上

6.1 搭建一个Connect程序
    安装：
    npm install connect

    Connect创建的“程序”实际上使一个javascript函数
    用来接收请求并把它怕发给你制定的中间件

    最小的connect程序
    var connect = require('connect');
    var app = connect();
    app.listen(3000);

    这是演示connect的分派器如何工作的第一个例子，
    它依次调用所有附着的中间件组件，
    直到其中一个响应该请求。
    如果直到中间件列表末尾还没有组件决定响应，
    程序会用404作为响应。

    接下来看看如何通过定义和添加中间件让这个程序做点事。

6.2 Connect的工作机制
    在connect中，中间件组件是一个javascript函数，
    按照惯例会接受三个参数：
        一个请求对象，
        一个响应对象，
        还有一个通常命名为next的参数，它使一个回调函数，
        表明这个组件已经完成了它的工作，可以执行下一个中间件组件了。

    中间件的概念最初使收到了ruby的rack框架的启发。

    这一节钥学习中间件的基础知识，
    我们会继续使用前一节那个connect准程序，
    在其中构建两个简单的中间件层：
        一个Logger 中间件组件将请求输出到控制台中
        一个hello中间件组件，用“hello world”响应请求

    我们先来创建将服务器收到的请求记录下来的中间件组件。


    6.2.1 做日志的中间件
        假设你想创建一个日志文件来记录进入服务器请求方法和URL。
        为此你需要创建一个函数，我们就叫它logger吧，
        它有三个参数：请求和响应对象，以及回调函数next

        next函数可以在中间件里调用，
        告诉分派器这个中间件已经完成了自己的任务，
        可以把控制权交给下一个中间件组件了。
        用回调函数，而不是从方法中返回，
        是为了可以在中间件组件里运行异步逻辑，
        这样分派器就只能等着前一个中间件组件完成后
        才会进入下一个中间件组件。
        用next()处理中间件组件之间的流程是不错的机制。

        对于logger中间件组件，
        你可以带着请求方法和URL调用console.log(),
        输出一些“GET /user/1”之类的东西，
        然后调用next()函数将控制权交给下一个组件：
        function logger(req, res, next) {
            console.log('%s %s', req.method, req.url);
            next();
        }
        就是它了一个完美的、有效的中间件组件、
        可以输出每个http请求的方法和URL，
        然后调用next()将控制权交给分派器
        要在程序中使用这个中间件，
        可以调用.use()方法，把中间件函数传给它：
        var connect = require('connect');
        var app = connect();
        app.use(logger);
        app.listen(3000);

        记录请求只是第一层中间件。
        你还需要给客户端发送某种响应。
        那是你的下一个中间件。

    6.2.2 响应“hello world”的中间件
        这个程序中第二个中间件会给http请求发送响应
        跟node首页那个"hello world" 服务器里的回调函数一样：
        function hello(req, res) {
            res.setHeader('Content-Type', 'text/plain');
            res.end('hello world');
        }

        你可以调用.use()方法 把第二个中间件添加到程序中，
        这个方法可以调用任意多次，
        添加更多的中间件
        代码minimal_conn.js把整个程序拼到一起
        这段代码这样添加hello中间件组件
        会让服务器首先调用logger
        向控制台中输出文本
        然后用“hello world”响应每个http请求：
        minimal_conn.js

        在这个例子中，中间件组件hello的参数中没有next回调
        因为这个组件结束了http响应
        从不需要把控制权交回给分派器
        对于这种情况，next回调是可选的
        因为这样跟http.createServer回调函数的签名一致所以更方便
        也就是如果你已经写了一个只使用http模块的http服务器
        你就已经有了一个完美的有效的中间件组件
        可以在你的connect程序中重用

        就像前面代码中写的那样
        use()函数返回的是支持方法链的Connect程序实例
        注意，.use()的链式调用不是必须的，比如下面这段代码：
        var app = connect();
        app.use(logger);
        app.use(hello);
        app.listen(3000);

        这个简单的"hello world"程序可以用了
        接下来我们要看看为什么中间件.use()调用的顺序很重要
        以及如何策略性的调整顺序改变程序的工作方式



6.3 为什么中间件的顺序很重要
    为了让程序和框架开发人员得到最大的灵活性
    Connect尽量不做假设
    Connect允许你定义中间件的执行顺序就是例证之一。
    这是一个简单的概念，但经常被忽视。

    你将在本节中见到中间件在程序中的顺序如何对他的行为方式产生显著的影响。
    具体来说，我们会涵盖如下几项内容：
        忽略next()从而停止后续中间件的执行;
        按照对你有力的方式使用强大的中间件顺序特性;
        例中中间件进行认证。
    我们先来看看Connect如何处理显式调用了next()的中间件组件。

    6.3.1 中间件什么时候不调用next()
        考虑下面的这个"hello world"的例子，
        先用了logger中间件组件，
        接着使hello组件。
        在这个例子中Connect向stdout中输出日志，
        然后响应http请求。
        请你考虑考虑如果改变一下顺序会怎么样
        .use(hello).use(logger)

        在这个例子还总，hello中间件组件先被调用，
        并如期响应http请求。
        但因为hello不会调用next(),
        控制权就不会被交回到分派器去调用下一个中间件组件，
        所以logger永远也不会被调用。
        我要说的使，当一个组件不调用next()时，
        命令链中的后续中间件都不会被调用。

        在这个例子中，把hello放到logger前面毫无用处，
        但如果应用得当，安排好顺序可以给带来好处。

    6.3.2 用中间件的顺序执行认证
        你可以按照对你有利的顺序安排中间件，
        比如在需要做认证时。
        几乎所有程序都会做认证。
        用户需要通过某种方式登录，
        而你需要防止没有登录的人访问某些内容。
        中间件的顺序可以帮你实现认证。

        假设你已经写了一个restrictFileAccess的中间件组件，
        只允许有效的用户访问文件。
        有效用户可以继续到下一个中间件组件，
        如果用户无效，则不会调用next()。
        在下面的代码清单中，
        中间件组件restrictFileAccess跟在中间件组件logger之后，
        但在serveStaticFiles组件之前。

        var connect = require('connect');
        connect()
            .use(logger)
            .use(restrictFileAccess)
            .use(serveStaticFiles)
            .use(hello);

        讨论完中间件的顺序，以及它对构造程序逻辑的重要性，
        接下来我们去看另外一个对你使用中间件有帮助的Connect特性。

6.4 挂载中间件和服务器
    6.4.1 认证中间件
    6.4.2 显示管理面板的中间件
6.5 创建可配置中间件
    6.5.1 创建可配置的logger中间件组件
    6.5.2 构建路由中间件组件
    6.5.3 构建一个重写URL的中间件组件
6.6 使用错误处理中间件
    6.6.1 Connect的默认错误处理器
    6.6.2 自行处理程序错误
    6.6.3 使用多个错误处理中间件组件

6.7 小结